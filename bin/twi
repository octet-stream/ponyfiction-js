#!/usr/bin/env node

const {ROOT, tryDeps} = require("./helper")
const {exec} = require("child_process")

process.title = "twi"
process.chdir(ROOT) // Change process.cwd() to Twi root directory

// Install deps (if not exists) before continue
tryDeps()

// And then we can use deps from NPM
const commander = require("commander")
const ora = require("ora")()
const {cross} = require("figures")
const {red} = require("chalk")

// DEPRECATED
const setEnv = isDev => isDev ? "development" : "production"

const getEnv = ({development, production, E} = {}) => {
  if (development) return "development"

  if (production) return "production"

  return E || "development"
}

/**
 * Process error handler
 *
 * @access private
 */
function onError(err, stackTrace = false) {
  ora.stop()

  if (stackTrace) {
    console.log(red(cross), err)
    console.log(red(cross), err.stack)
  } else {
    ora.text = String(err)
    ora.fail()
  }

  process.exit(1)
}

/**
 * Success callback
 *
 * @access private
 */
function onEnd() {
  ora.text = "Done without errors."
  ora.succeed()
  process.exit(0)
}

/**
 * Compile frontend app
 */
const runCompiler = () => new Promise((resolve, reject) => {
  const fulfill = err => err ? reject(err) : resolve()

  const onGulpFinished = err => (
    err ? reject(err) : exec(`${ROOT}/node_modules/.bin/next build`, fulfill)
  )

  exec(`${ROOT}/node_modules/.bin/gulp`, onGulpFinished)
})

/**
 * Make backend app
 *
 * @return Promise
 */
const makeBackend = () => new Promise((resolve, reject) => {
  const fulfill = err => err ? reject(err) : resolve()

  ora.color = "cyan"
  ora.text = "Making backend app..."
  ora.start()

  exec(`${ROOT}/bin/cake make`, fulfill)
})

/**
 * Make frontend app
 *
 * @return Promise
 */
function makeFrontend() {
  ora.color = "yellow"
  ora.text = "Making frontend app..."
  ora.start()

  return runCompiler(false)
}

/**
 * Make app components
 *
 * @param component
 */
function make(component) {
  setEnv(false) // set NODE_ENV to production

  // Build specified component
  switch (component) {
    case "backend": return makeBackend()

    case "frontend": return makeFrontend()

    default: return makeBackend().then(makeFrontend)
  }
}

// Not implemented
// function migrate(cmd) {
//   setEnv(false)

//   const migrate = require(`${ROOT}/setup/server/migrate`).default

//   let promise
//   if (cmd.D) {
//     promise = migrate.importData(cmd.E).then(() => migrate.createSu(cmd.R))
//   } else {
//     promise = migrate(cmd)
//   }

//   promise.then(onEnd, onError)
// }

/**
 * Execute installation process.
 *
 * @param commander.Command
 */
function setup(cmd) {
  setEnv(false)

  function onFulfilled() {
    ora.stop()

    return require(`${ROOT}/setup/server/installer`).default(cmd)
  }

  const onRejected = err => onError(err, cmd.parent.T)

  if (cmd.ignoreFirstStage) {
    return onFulfilled().then(onEnd, onRejected)
  }

  make(undefined).then(onFulfilled).then(onEnd, onRejected)
}

function run(name, cmd) {
  const env = getEnv(cmd.parent)
  const isDev = env !== "production"

  setEnv(isDev) // tmp

  const onRejected = err => onError(err, cmd.parent.T)

  let service
  try {
    service = require(`${ROOT}/server/${name}/core/base/main`).default
  } catch (err) {
    return onRejected(err)
  }

  const res = service(isDev, env)

  res instanceof Promise
    ? res.catch(onRejected)
    : onRejected(new Error("Service executor should return a Promise."))
}

// Build Twi fron the source
const actionMake = (component, cmd) => (
  make(component, cmd).then(onEnd, err => onError(err, cmd.parent.T))
)

// Run only Twi miration (without full setup)
// const actionMigrate = cmd => migrate(cmd)

// Run Twi setup scripts
const actionSetup = cmd => setup(cmd)

// Run Twi app for production
const actionRun = (...args) => run(...args)

commander
  .version(require(`${ROOT}/package.json`).version)
  .usage("[options] <command>")

commander
  .option("--stack-trace, -t", "show stack trace on errors")
  .option("--development", "set env to development")
  .option("--production", "set env to production")
  .option("--debug", "set env to debug")
  .option("--test", "set env to test")
  .option("--env, -e [env]", "set an environment for an application")

commander
  .command("setup")
  .alias("s")
  .description("run installer script")
  .option(
    "--skip-register, -s",
    "skip owner account registration (use it ONLY for CI)"
  )
  .option(
    "--register, -r", "create owner account while installation using console"
  )
  .option("--not-erase, -e", "run installer without data erasing")
  .option("--configure, -c", "configure app while installation using console")
  .option("--ignore-first-stage", "ingore app making stage")
  .action(actionSetup)

// commander
//   .command("migrate")
//   .alias("m")
//   .description("run only migrations script")
//   .option(
//     "--skip-register, -s",
//     "skip owner account registration (use it ONLY for CI)"
//   )
//   .option(
//     "--register, -r", "create owner account while installation using console"
//   )
//   .option("--not-erase, -e", "run migrate without data erasing")
//   .option("--data-only, -d", "run only data imports")
//   .action(actionMigrate)

commander
  .command("run <service>")
  .alias("r")
  .description("run specified Twi's service")
  .action(actionRun)

commander
  .command("make [component]")
  .alias("m")
  .description("Build Twi components")
  .action(actionMake)

commander
  .parse(process.argv)

process
  .on("error", onError)
  .on("SIGINT", () => process.exit(0))
