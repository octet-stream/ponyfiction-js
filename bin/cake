#!/usr/bin/env node

/**
 * Build your Babel project with a cake!
 *
 * @license MIT
 * @author Nick K. <https://github.com/octet-stream>
 */
const {dirname, resolve, isAbsolute} = require("path")
const fs = require ("fs")

const {ROOT, tryDeps} = require("./helper")

tryDeps() // Check deps before including external packages

const commander = require("commander")
const {cross, tick, pointer} = require("figures")
const vfs = require("vinyl-fs")
const glob = require("glob")
const junk = require("junk")
const rimraf = require("rimraf")
const through = require("through2")
const ora = require("ora")({stream: process.stdout})
const applySourceMap = require("vinyl-sourcemaps-apply")
const sourcemaps = require("gulp-sourcemaps")
const {red, green, cyan} = require("chalk")
const {noop} = require("gulp-util")
const chokidar = require("chokidar")

const {transform} = require("babel-core")

const BABERC = JSON.parse(fs.readFileSync(resolve(ROOT, ".babelrc")))

const DEFAULT_SRC = `${ROOT}/src`

const assign = Object.assign

var isDev = false

const resolveFullSrcPath = (path = DEFAULT_SRC) => (
  isAbsolute(path) ? path : resolve(ROOT, path)
)

const resolveFullDestPath = (path = ROOT) => (
  isAbsolute(path) ? path : resolve(ROOT, path)
)

const getDestFilename = (filename, src, dest) => (
  filename.replace(src, dest)
)

/**
 * Check if given file is JS
 *
 * @param string filename – a path to file
 */
const isJS = filename => /.jsx?$/.test(filename)

const onContinueWatching = () => (
  console.log(cyan(pointer), "Watching for changes...")
)

/**
 * Just a callback to end the cake process
 */
function onEnd() {
  if (isDev) {
    console.log(`\n${green(tick)}`, "Done.")
  } else {
    ora.text = "Done."
    ora.succeed()
  }

  process.exit(0)
}

/**
 * Error hanlder for all in-process errors
 *
 * @param Error err
 */
function onError(err) {
  if (isDev) {
    console.log(err)
    return console.log(red(cross), "Watching for changes...")
  }

  ora.stop()
  console.log(red(cross), err)
  process.exit(1)
}

/**
 * Add event handlers to Chocidar watcher
 *
 * @param chokidar.FSWatcher watcher
 * @param object handlers
 */
function mapHandlers(watcher, handlers) {
  const hasOwn = prop => handlers.hasOwnProperty(prop)

  for (let name in handlers) {
    if (!hasOwn(name)) {
      continue
    }

    const handler = handlers[name]

    // Cut and decapitalize handler name
    if (name.startsWith("on")) {
      name = name.slice(2)
      name = name.charAt(0).toLowerCase() + name.slice(1)
    }

    watcher.on(name, handler)
  }

  return watcher
}

/**
 * Compile given file via Babel
 *
 * @param File file – a file in Vinyl virtual file format
 * @param env – file encoding
 * @param function cb
 */
function compileFile(file, enc, cb) {
  if (!isJS(file.path)) {
    console.log(cyan(pointer), `Copy ${file.path}`)
    return cb(null, file)
  }

  if (isDev) {
    console.log(cyan(pointer), `Compile ${file.path}`)
  } else {
    ora.color = "cyan"
    ora.text = `Compile ${file.path}`
  }

  try {
    const contents = transform(String(file.contents),
      assign({}, BABERC, {
        filename: file.path,
        filenameRelative: file.relative,
        sourceMap: isDev ? "inline" : true,
        sourceFileName: file.relative,
        sourceMapTarget: file.relative
      })
    )

    if (file.sourceMap && contents.map && !isDev) {
      applySourceMap(file, contents.map)
    }

    file.contents = new Buffer(contents.code)
    file.babel = contents.metadata
  } catch (err) {
    return cb(err)
  }

  return cb(null, file)
}

/**
 * Process given files via vinyl-fs, through2 and babel
 *
 * @param array files
 * @param string src
 * @param string dest
 */
function processFiles(files, src, dest) {
  files = files.filter(file => junk.not(file) && file !== DEFAULT_SRC)

  // Get destination path for each given file
  const fulfill = ({path}) => dirname(getDestFilename(path, src, dest))

  vfs.src(files)
    .on("error", onError)
    .pipe(isDev ? noop() : sourcemaps.init())
    .on("error", onError)
    .pipe(through.obj(compileFile))
    .on("error", onError)
    .pipe(isDev ? noop() : sourcemaps.write("."))
    .on("error", onError)
    .pipe(vfs.dest(fulfill))
    .on("error", onError)
    .on("end", isDev ? onContinueWatching : onEnd)
}

function make(src, dest) {
  ora.start()

  const fulfill = (err, files) => (
    err == null ? processFiles(files, src, dest) : onError(err)
  )

  glob(`${src}/**`, fulfill)
}

/**
 * Run cake in "watch" mode for development
 *
 * @param string src
 * @param string dest
 */
function watch(src, dest) {
  isDev = true // Turning on development mode

  console.log(cyan(pointer), "Starting watcher...")
  console.log(cyan(pointer), "You can press Control+C to exit.")

  /**
   * Event handler for fs.watch method
   * Rebuild changed/deleted and added files/directories.
   *
   * @param Event e
   * @param string filename
   */
  // function watcher(e, filename) {
  //   filename = `${src}/${filename}`

  //   const destFilename = getDestFilename(filename, src, dest)

  //   try {
  //     const stat = fs.statSync(filename)

  //     // TODO: Add recompile files in created directory (if they exists)
  //     if (stat.isDirectory()) {
  //       console.log(`Creating a directory ${filename}`)

  //       // Rebuild files in directory if they exists
  //       const fulfill = (err, files) => (
  //         err == null ? processFiles(files, src, dest) : onError(err)
  //       )

  //       // Find files in created directory
  //       const created = err => (
  //         err == null ? glob(`${filename}/**`, fulfill) : onError(err)
  //       )

  //       return fs.mkdir(destFilename, created)
  //     }

  //     return processFiles([filename], src, dest)
  //   } catch (err) {
  //     if (err.code !== "ENOENT") {
  //       return process.emit("error", err)
  //     }

  //     const fulfill = err => (
  //       err == null ? console.log(`Remove ${destFilename}`) : onError(err)
  //     )

  //     rimraf(destFilename, fulfill)
  //   }
  // }

  // // Run watcher
  // fs.watch(src, {recursive: true}, watcher)

  // Get full path to given file
  // const getFilename = filename => resolve(`${src}/${filename}`)

  /**
   * Create a directory on "addDir" event and compile included files (if exists)
   *
   * @param string filename
   */
  function onAddDir(filename) {
    const fulfill = (err, files) => (
      err ? onError(err) : processFiles(files)
    )

    const created = err => err ? onError(err) : glob(`${filename}/**`, fulfill)

    const destFilename = getDestFilename(filename, src, dest)

    fs.mkdir(destFilename, created)
  }

  /**
   * Rebuild given file on "add" event
   *
   * @param string filename
   */
  const onAdd = filename => processFiles([filename], src, dest)

  const onUnlink = filename => fs.unlink(
    getDestFilename(filename, src, dest), err => err && onError(err)
  )

  const onUnlinkDir = filename => rimraf(
    getDestFilename(filename, src, dest), err => err && onError(err)
  )

  function onChange(filename, stat) {
    const fulfill = stat => (
      stat.isDirectory() ? onAddDir(filename) : onAdd(filename)
    )

    const onStat = (err, stat) => err ? onError(err) : fulfill(stat)

    stat && typeof stat.isDirectory === "function"
      ? fulfill(stat)
      : fs.stat(filename, onStat)
  }

  // Create chokidar.FSWatcher instance that watches for "src" path
  const watcher = chokidar.watch(src, {
    ignoreInitial: true
  })

  // Add handlers to watcher
  mapHandlers(watcher, {
    onError,
    onAdd,
    onAddDir,
    onChange,
    onUnlink,
    onUnlinkDir
  })
}

// Run "make" command
const actionMake = ({parent: {S, D}}) => make(
  resolveFullSrcPath(S),
  resolveFullDestPath(D)
)

// Run "watch" command
const actionWatch = ({parent: {S, D}}) => watch(
  resolveFullSrcPath(S),
  resolveFullDestPath(D)
)

commander
  .command("make")
  .alias("m")
  .description("Make project")
  .action(actionMake)

commander
  .command("watch")
  .alias("w")
  .description("Run watcher for development")
  .action(actionWatch)

commander
  .option("--src, -s <directory>", "Set custom source directory")
  .option("--dest, -d <directory>", "Set custom destination directory")
  .version("The cake is a lie!\nCurrent cake version is 2.0.1")
  .parse(process.argv)

process
  .on("SIGINT", onEnd)
  .on("error", onError)
