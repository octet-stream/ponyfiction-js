#!/usr/bin/env node

/**
 * Build your Babel project with a cake!
 *
 * @license MIT
 * @author Nick K. <https://github.com/octet-stream>
 */
const {dirname, resolve, isAbsolute} = require("path")
const fs = require ("fs")

const {ROOT, tryDeps} = require("./helper")

tryDeps() // Check deps before including external packages

const commander = require("commander")
const {cross, tick, pointer} = require("figures")
const vfs = require("vinyl-fs")
const glob = require("glob")
const junk = require("junk")
const rimraf = require("rimraf")
const through = require("through2")
const ora = require("ora")({stream: process.stdout})
const applySourceMap = require("vinyl-sourcemaps-apply")
const sourcemaps = require("gulp-sourcemaps")
const {red, green, cyan} = require("chalk")
const {noop} = require("gulp-util")

const {transform} = require("babel-core")

const BABERC = JSON.parse(fs.readFileSync(resolve(ROOT, ".babelrc")))

const DEFAULT_SRC = `${ROOT}/src`

const assign = Object.assign

var isDev = false

const resolveFullSrcPath = (path = DEFAULT_SRC) => (
  isAbsolute(path) ? path : resolve(ROOT, path)
)

const resolveFullDestPath = (path = ROOT) => (
  isAbsolute(path) ? path : resolve(ROOT, path)
)

const getDestFilename = (filename, src, dest) => (
  filename.replace(src, dest)
)

/**
 * Check if given file is JS
 *
 * @param string filename – a path to file
 */
const isJS = filename => /.jsx?$/.test(filename)

const onContinueWatching = () => (
  console.log(cyan(pointer), "Watching for changes...")
)

/**
 * Just a callback to end the cake process
 */
function onEnd() {
  if (isDev) {
    console.log(`\n${green(tick)}`, "Done.")
  } else {
    ora.text = "Done."
    ora.succeed()
  }

  process.exit(0)
}

/**
 * Error hanlder for all in-process errors
 *
 * @param Error err
 */
function onError(err) {
  if (isDev) {
    return console.log(red(cross), "Watching for changes...")
  }

  ora.stop()
  console.log(red(cross), err)
  process.exit(1)
}

/**
 * Compile given file via Babel
 *
 * @param File file – a file in Vinyl virtual file format
 * @param env – file encoding
 * @param function cb
 */
function compileFile(file, enc, cb) {
  if (!isJS(file.path)) {
    return cb(null, file)
  }

  if (isDev) {
    console.log(cyan(pointer), `Compile ${file.path}`)
  } else {
    ora.color = "cyan"
    ora.text = `Compile ${file.path}`
  }

  try {
    const contents = transform(String(file.contents),
      assign({}, BABERC, {
        filename: file.path,
        filenameRelative: file.relative,
        sourceMap: isDev ? "inline" : true,
        sourceFileName: file.relative,
        sourceMapTarget: file.relative
      })
    )

    if (file.sourceMap && contents.map && !isDev) {
      applySourceMap(file, contents.map)
    }

    file.contents = new Buffer(contents.code)
    file.babel = contents.metadata
  } catch (err) {
    return cb(err)
  }

  return cb(null, file)
}

/**
 * Process given files via vinyl-fs, through2 and babel
 *
 * @param array files
 * @param string src
 * @param string dest
 */
function processFiles(files, src, dest) {
  files = files.filter(file => junk.not(file) && file !== DEFAULT_SRC)

  // Get destination path for each given file
  const fulfill = ({path}) => dirname(getDestFilename(path, src, dest))

  vfs.src(files)
    .on("error", onError)
    .pipe(isDev ? noop() : sourcemaps.init())
    .on("error", onError)
    .pipe(through.obj(compileFile))
    .on("error", onError)
    .pipe(isDev ? noop() : sourcemaps.write("."))
    .on("error", onError)
    .pipe(vfs.dest(fulfill))
    .on("error", onError)
    .on("end", isDev ? onContinueWatching : onEnd)
}

function make(src, dest) {
  ora.start()

  const fulfill = (err, files) => (
    err == null ? processFiles(files, src, dest) : onError(err)
  )

  glob(`${src}/**`, fulfill)
}

/**
 * Run cake in "watch" mode for development
 *
 * @param string src
 * @param string dest
 */
function watch(src, dest) {
  isDev = true // Turning on development mode

  console.log(cyan(pointer), "Starting watcher...")
  console.log(cyan(pointer), "You can press Control+C to exit.")

  /**
   * Event handler for fs.watch method
   * Rebuild changed/deleted and added files/directories.
   *
   * @param Event e
   * @param string filename
   */
  function watcher(e, filename) {
    filename = `${src}/${filename}`

    const destFilename = getDestFilename(filename, src, dest)

    try {
      const stat = fs.statSync(filename)

      // TODO: Add recompile files in created directory (if they exists)
      if (stat.isDirectory()) {
        console.log(`Creating a directory ${filename}`)

        // Rebuild files in directory if they exists
        const fulfill = (err, files) => (
          err == null ? processFiles(files, src, dest) : onError(err)
        )

        // Find files in created directory
        const created = err => (
          err == null ? glob(`${filename}/**`, fulfill) : onError(err)
        )

        return fs.mkdir(destFilename, created)
      }

      if (isJS(filename)) {
        return processFiles([filename], src, dest)
      }
    } catch (err) {
      if (err.code !== "ENOENT") {
        return process.emit("error", err)
      }

      const fulfill = err => (
        err == null ? console.log(`Remove ${destFilename}`) : onError(err)
      )

      rimraf(destFilename, fulfill)
    }
  }

  // Run watcher
  fs.watch(src, {recursive: true}, watcher)
}

// Run "make" command
const actionMake = ({parent: {S, D}}) => make(
  resolveFullSrcPath(S),
  resolveFullDestPath(D)
)

// Run "watch" command
const actionWatch = ({parent: {S, D}}) => watch(
  resolveFullSrcPath(S),
  resolveFullDestPath(D)
)

commander
  .command("make")
  .alias("m")
  .description("Make project")
  .action(actionMake)

commander
  .command("watch")
  .alias("w")
  .description("Run watcher for development")
  .action(actionWatch)

commander
  .option("--src, -s <directory>", "Set custom source directory")
  .option("--dest, -d <directory>", "Set custom destination directory")
  .version("The cake is a lie!\nCurrent cake version is 2.0.1")
  .parse(process.argv)

process
  .on("SIGINT", onEnd)
  .on("error", onError)
